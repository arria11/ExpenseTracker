@page "/transactions"
@using ExpenseTracker.Model
@using ExpenseTracker.Services
@inject ITransactionService transactionService
@inject AuthenticationStateService authStateService
@inject TagService tagService
@inject CalculateTransactionService calculateTransactionService

<style>
    .container {
        width: 90%;
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
        font-family: Arial, sans-serif;
    }

    .filter-bar {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 10px;
        margin-bottom: 20px;
    }

    .type-filter-bar input[type="text"] {
        width: 400px;
        padding: 8px;
        border: 1px solid #ccc;
        border-radius: 5px;
        background-color: #f4fcff;
    }

    .filter-bar input[type="date"] {
        padding: 8px;
        border: 1px solid #ccc;
        border-radius: 5px;
        background-color: #f4fcff;
    }

    .type-filter-bar {
        display: flex;
        justify-content: space-between;
        gap: 20px;
        margin-bottom: 20px;
    }

    .type-filter-bar button {
        background-color: #30718A;
        color: white;
        padding: 8px 60px;
        border: none;
        border-radius: 5px;
        font-size: 14px;
        cursor: pointer;
    }
    .filter-bar button {
        background-color: #30718A;
        color: white;
        padding: 8px 30px;
        border: none;
        border-radius: 5px;
        font-size: 14px;
        cursor: pointer;
    }

    .type-filter-bar button.active {
        background-color: #000000;
    }

    table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 20px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    }

    th,
    td {
        padding: 10px;
        text-align: center;
        border: 1px solid #ccc;
    }

    th {
        background-color: #30718A;
        color: white;
        font-weight: bold;
    }

    td {
        background-color: #f4fcff;
    }

    td button {
        background-color: #30718A;
        color: white;
        padding: 5px 10px;
        border: none;
        border-radius: 3px;
        cursor: pointer;
    }

    td button:hover {
        background-color: #255C71;
    }

    .totals-section {
        margin-top: 20px;
        text-align: right;
        font-weight: bold;
        padding: 10px 0;
    }

    .action-icons {
        display: flex;
        justify-content: center;
        gap: 5px;
    }

    .action-icons button {
        padding: 8px;
        background-color: transparent;
        border: none;
        cursor: pointer;
    }

    .action-icons button:hover {
        transform: scale(1.1);
    }

    .action-icons img {
        width: 20px;
        height: 20px;
    } 
</style>


@if (!string.IsNullOrEmpty(alertMessage))
{
    <div>
        @alertMessage
        <button @onclick="ClearAlert">Close</button>
    </div>
}


<container>
    <div class="type-filter-bar">
        <input type="text" placeholder="Search transactions..." @oninput="SearchTransactions" />
        <button @onclick="() => FilterType(0)">Inflow</button>
        <button @onclick="() => FilterType(1)">Outflow</button>
        <button @onclick="() => FilterType(2)">Debt</button>
    </div>

    <div class="filter-bar">
        <label for="dateSort">Start Date</label> <input type="date" @bind="fromDate" placeholder="Start Date" />
         <label for="dateSort">End Date</label><input type="date" @bind="toDate" placeholder="End Date" />
         <button @onclick="ApplyFilters">Apply Filter</button>
        <button @onclick="ClearFilters">Clear Filters</button>
    </div>

    <div class="tag-filter-bar">
        <label for="tagFilter">Filter by Tag:</label>
            <select id="tagFilter" @onchange="FilterByTag">
                <option value="">All Tags</option>
                 @foreach (var tag in tags)
                    {
                        <option value="@tag">@tag</option>
                    }
            </select>
    </div>

    <div class="sort-bar">
        <label for="dateSort">Sort by Date:</label>
        <select id="dateSort"  @onchange="SortTransactions">
            <option value="latest">Latest</option>
            <option value="oldest">Oldest</option>
        </select>
    </div>

    <table>
        <thead>
            <tr>
                <th>Title</th>
                <th>Amount</th>
                <th>Date</th>
                <th>Tag</th>
                <th>Note</th>
                @if (currentFilter == 2) 
                {
                    <th>Source</th>
                    <th>Due Date</th>
                    <th>Status</th>
                }
            </tr>
        </thead>
        <tbody>
            @if (filteredTransaction != null && filteredTransaction.Any())
            {
                @foreach (var transaction in filteredTransaction)
                {
                    <tr>
                        <td>@transaction.Title</td>
                        @if (authStateService.IsAuthenticated())
                        {
                            <td>@authStateService.GetAuthenticatedUser().Currency @transaction.Amount</td>
                        }
                        <td>@transaction.Date.ToString("MMMM d, yyyy")</td>
                        <td>@(transaction.Tag == "Other" ? transaction.CustomTag : transaction.Tag)</td>

                    
                        <td>@(string.IsNullOrEmpty(transaction.Note) ? "No Note Available" : transaction.Note)</td>
                        @if (currentFilter == 2) 
                        {
                            <td>@transaction.Source</td>
                            <td>@(transaction.DueDate?.ToString("MMMM d, yyyy") ?? "No Due Date")</td>
                            <td>
                                @if (transaction.IsCleared)
                                {
                                    <span>Cleared</span>
                                }
                                else
                                {
                                    <button @onclick="() => MarkAsCleared(transaction)" disabled="@transaction.IsCleared">Clear</button>
                                }
                            </td>
                        }                      
                    </tr>
                }
            }
            else
            {
                <tr>
                    <td colspan="@((currentFilter == 2) ? 8 : 6)">No transactions available.</td>
                </tr>
            }

            @if (!string.IsNullOrEmpty(errorMessage))
            {
                <div class="alert alert-danger">
                    @errorMessage
                </div>
            }

            @if (currentFilter == 0)
            {
                <div>
                    <br/>
                    <h5>Inflow Amount: @totalInflow</h5>
                </div>
            }
            else if (currentFilter == 1)
            {
                <div>
                    <br />
                    <h5>Total Outflow: @totalOutflow</h5>
                </div>
            }
            else if (currentFilter == 2)
            {
                <div>
                    <br />
                    <h5>Total Debt: @totalDebt</h5
                    <h5>Pending Debt: @pendingDebt</h5>
                    <h5>Cleared Debt:@clearedDebt</h5>
                </div>
            }
        </tbody>
    </table>
</container>

@code {
    private List<TransactionItem> transaction = new List<TransactionItem>();
    private List<TransactionItem> filteredTransaction = new List<TransactionItem>();
    private string? alertMessage;
    private int currentFilter = 0;
    private string selectedSortOption = "latest";
    private decimal inflowAmount = 0;
    private decimal totalInflow;
    private decimal totalOutflow = 0;
    private decimal totalDebt = 0;
    private decimal pendingDebt;
    private decimal clearedDebt;
    private CalculateTransaction transactionTotals;
    private string searchText = string.Empty;
    private string selectedTag = string.Empty;
    private DateTime? fromDate;
    private DateTime? toDate;
    private bool isSearching = false;
    private List<string> tags = new();
    private string? errorMessage;


    protected override void OnInitialized()
    {
        tags = tagService.GetTags();
    }


    private void ClearFilters()
    {
        searchText = string.Empty;
        fromDate = null;
        toDate = null;
        ApplyFilters();
    }

    /*private void CalculateTotals()
    {
        inflowAmount = filteredTransaction.Where(t => t.Type == "Inflow").Sum(t => t.Amount); 
        totalOutflow = filteredTransaction.Where(t => t.Type == "Outflow").Sum(t => t.Amount); 
        totalDebt = filteredTransaction.Where(t => t.Type == "Debt").Sum(t => t.Amount); 
        clearedDebt = filteredTransaction.Where(t => t.Type == "Debt" && t.IsCleared).Sum(t => t.Amount); 
        pendingDebt = totalDebt - clearedDebt; 
        totalInflow = inflowAmount - clearedDebt;
    }*/

    private async Task LoadTransaction()
    {
        transaction = await transactionService.LoadTransactionAsync();
        ApplyFilters();
    }

    protected override async Task OnInitializedAsync()
    {
        await LoadTransaction();
        FilterType(0); // Default filter: Inflow
    }

    private void ClearAlert()
    {
        alertMessage = null;
    }

    private void SearchTransactions(ChangeEventArgs e)
    {
        searchText = e.Value?.ToString()?.ToLower() ?? string.Empty;
        isSearching = true;
        ApplyFilters();
    }

    private void FilterByTag(ChangeEventArgs e)
    {
        selectedTag = e.Value?.ToString() ?? string.Empty;
        ApplyFilters();
    }

    private void FilterType(int type)
    {
        currentFilter = type;
        ApplyFilters();
    }

    private void SortTransactions(ChangeEventArgs e)
    {
        selectedSortOption = e.Value?.ToString() ?? "latest"; 
        ApplyFilters(); 
    }

    private void ApplyFilters()
    {
        filteredTransaction = transaction
            .Where(t =>
                (currentFilter == 0 && t.Type == "Inflow") ||
                (currentFilter == 1 && t.Type == "Outflow") ||
                (currentFilter == 2 && t.Type == "Debt"))
             .Where(t => string.IsNullOrEmpty(searchText) ||
                    t.Title.ToLower().Contains(searchText)) 
            .Where(t => string.IsNullOrEmpty(selectedTag) || t.Tag == selectedTag || (t.Tag == "Other" && t.CustomTag == selectedTag))
            .Where(t => (!fromDate.HasValue || t.Date >= fromDate.Value) && (!toDate.HasValue || t.Date <= toDate.Value))
            .ToList();
            // Calculating the totals after filtering
            var result = calculateTransactionService.CalculateTransactionTotals(filteredTransaction);

            totalInflow = result.InflowAmount;
            totalOutflow = result.TotalOutflow;
            totalDebt = result.TotalDebt;
            pendingDebt = result.PendingDebt;
            clearedDebt = result.ClearedDebt;

            if (selectedSortOption == "latest")
            {
                filteredTransaction = filteredTransaction.OrderByDescending(t => t.Date).ToList();
            }
            else if (selectedSortOption == "oldest")
            {
                filteredTransaction = filteredTransaction.OrderBy(t => t.Date).ToList();
            }
        
    }

   private async Task MarkAsCleared(TransactionItem transaction)
{
    // Reload all transactions
    var transactions = await transactionService.LoadTransactionAsync();

    // Calculate totals using the service
    var result = calculateTransactionService.CalculateTransactionTotals(transactions);

    totalInflow = result.InflowAmount;
    totalOutflow = result.TotalOutflow;
    totalDebt = result.TotalDebt;
    pendingDebt = result.PendingDebt;
    clearedDebt = result.ClearedDebt;

    // Ensure that the total inflow minus cleared debt is greater than or equal to the transaction amount
    var availableInflow = totalInflow - clearedDebt;

    if (transaction.Amount <= availableInflow)
    {
        // Mark the transaction as cleared
        transaction.IsCleared = true;

        // Update the transaction in the data source
        await transactionService.UpdateTransactionAsync(transaction);

        // Refresh the filtered transactions to reflect the updated status
        ApplyFilters();

        // Clear any previous error message
        errorMessage = null;
    }
    else
    {
        // Set an error message if the transaction amount exceeds the available inflow
        errorMessage = "Cannot clear this debt as the amount exceeds the available inflow.";
    }
}
}
